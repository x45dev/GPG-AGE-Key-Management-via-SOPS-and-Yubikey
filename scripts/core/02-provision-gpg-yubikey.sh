#!/usr/bin/env bash
# scripts/core/02-provision-gpg-yubikey.sh
# Provisions a YubiKey with GPG subkeys (Sign, Encrypt, Authenticate).
# This script configures the YubiKey's OpenPGP applet and moves the
# previously generated GPG subkeys onto the hardware token.

SHELL_OPTIONS="set -e -u -o pipefail"
# set -e: Exit immediately if a command exits with a non-zero status.
# set -u: Treat unset variables as an error when substituting.
# set -o pipefail: The return value of a pipeline is the status of the last command to exit with a non-zero status, or zero if no command exited with a non-zero status.
eval "$SHELL_OPTIONS"

BASE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
LIB_SCRIPT_PATH="${BASE_DIR}/scripts/lib/common.sh"

if [ ! -f "$LIB_SCRIPT_PATH" ]; then
    echo "Error: common.sh not found at $LIB_SCRIPT_PATH"
    exit 1
fi
# shellcheck source=scripts/lib/common.sh
# Load common library functions (logging, prompts, etc.)
source "$LIB_SCRIPT_PATH"

# --- Usage Function ---
usage() {
    echo "Usage: $(basename "$0") --serial <YUBIKEY_SERIAL>"
    echo ""
    echo "This script provisions a specified YubiKey with GPG subkeys (Sign, Encrypt, Authenticate)."
    echo "It assumes GPG master and subkeys have been generated by '01-generate-gpg-master-key.sh'"
    echo "and are available in the temporary GPG home or the user's default GPG home."
    echo ""
    echo "Arguments:"
    echo "  --serial <YUBIKEY_SERIAL>   The serial number of the YubiKey to provision."
    echo "                              You can find this using 'ykman list --serials'."
    echo ""
    echo "The script will:"
    echo "  1. Connect to the specified YubiKey."
    echo "  2. Optionally reset the YubiKey's OpenPGP applet (with confirmation)."
    echo "  3. Guide you to set new User and Admin PINs for the OpenPGP applet."
    echo "  4. Optionally set cardholder information."
    echo "  5. Move the Sign, Encrypt, and Authenticate GPG subkeys to the YubiKey."
    echo "     (Ensures local private subkey stubs are preserved for backup/cloning)."
    echo "  6. Set touch policies for the GPG keys on the YubiKey."
    echo ""
    echo "Prerequisites:"
    echo "  - GPG master key and subkeys must have been generated (e.g., by 01-generate-gpg-master-key.sh)."
    echo "  - The GPG master key ID must be stored in '${GPG_MASTER_KEY_ID_FILE:-.gpg_master_key_id}'."
    echo "  - Required tools: gpg, ykman, gpg-connect-agent."
    echo "  - The YubiKey must be connected."
    echo ""
    echo "Environment variables like GPG_USER_NAME (for cardholder name), GPG_TOUCH_POLICY_*"
    echo "and OPENPGP_MIN_USER_PIN_LENGTH, OPENPGP_MIN_ADMIN_PIN_LENGTH"
    echo "can be set to customize behavior (see .mise.toml)."
    exit 1
}

# Default PINs for YubiKey OpenPGP applet (used when changing PINs)
DEFAULT_USER_PIN="123456"
DEFAULT_ADMIN_PIN="12345678"

# Configuration for GPG touch policies on the YubiKey
GPG_TOUCH_POLICY_SIG="${GPG_TOUCH_POLICY_SIG:-cached}" # on, off, fixed, cached
GPG_TOUCH_POLICY_ENC="${GPG_TOUCH_POLICY_ENC:-cached}"
GPG_TOUCH_POLICY_AUT="${GPG_TOUCH_POLICY_AUT:-cached}"
# Configuration for minimum PIN lengths (for user prompts)
OPENPGP_MIN_USER_PIN_LENGTH_CONFIG="${OPENPGP_MIN_USER_PIN_LENGTH:-6}"
OPENPGP_MIN_ADMIN_PIN_LENGTH_CONFIG="${OPENPGP_MIN_ADMIN_PIN_LENGTH:-8}"

# Script-specific variables
YK_SERIAL=""
MASTER_KEY_ID=""

# Variables for holding new PINs and passphrases temporarily
NEW_USER_PIN_VALUE=""
NEW_ADMIN_PIN_VALUE=""
NEW_ADMIN_PIN_FOR_RESET="" # For resetting the applet
GPG_MASTER_PASSPHRASE=""   # For authorizing subkey transfer
CONFIRM_NEW_USER_PIN_VALUE=""
CONFIRM_NEW_ADMIN_PIN_VALUE=""

# --- Script Specific Cleanup Function ---
# Registered with `trap` in common.sh to run on EXIT.
script_specific_cleanup() {
    local exit_status_for_cleanup=${1:-$?}
    log_debug "Running script_specific_cleanup for 02-provision-gpg-yubikey.sh with status $exit_status_for_cleanup"
    # Unset sensitive variables from script memory
    unset NEW_USER_PIN_VALUE NEW_ADMIN_PIN_VALUE NEW_ADMIN_PIN_FOR_RESET GPG_MASTER_PASSPHRASE
    unset CONFIRM_NEW_USER_PIN_VALUE CONFIRM_NEW_ADMIN_PIN_VALUE
}

# --- Function to get and display YubiKey OpenPGP status ---
get_and_display_yk_openpgp_status() {
    local yk_serial_for_status="$1"
    log_info "Fetching OpenPGP status for YubiKey S/N ${yk_serial_for_status}..."
    local yk_status_output
    local yk_status_ec
    yk_status_output=$(ykman -s "${yk_serial_for_status}" openpgp info 2>&1)
    yk_status_ec=$?

    if [ $yk_status_ec -ne 0 ]; then
        log_warn "Could not fetch OpenPGP status from YubiKey S/N ${yk_serial_for_status}. ykman EC: $yk_status_ec"
        log_warn "ykman output:\n${yk_status_output}"
        return 1
    fi

    log_debug "YubiKey S/N ${yk_serial_for_status} OpenPGP Info:\n${yk_status_output}"

    local pin_tries admin_pin_tries reset_code_tries
    pin_tries=$(echo "${yk_status_output}" | grep "PIN tries remaining:" | awk '{print $4}')
    admin_pin_tries=$(echo "${yk_status_output}" | grep "Admin PIN tries remaining:" | awk '{print $5}') # Field can vary
    if [ -z "$admin_pin_tries" ]; then # Try another common field position if first fails
        admin_pin_tries=$(echo "${yk_status_output}" | grep "Admin PIN tries remaining:" | awk '{print $4}')
    fi
    reset_code_tries=$(echo "${yk_status_output}" | grep "Resetting code tries remaining:" | awk '{print $5}')

    log_info "  User PIN tries remaining: ${pin_tries:-N/A}"
    log_info "  Admin PIN tries remaining: ${admin_pin_tries:-N/A}"
    log_info "  Resetting code tries remaining: ${reset_code_tries:-N/A}"

    if [[ "${pin_tries}" == "1" || "${admin_pin_tries}" == "1" ]]; then
        log_warn "CRITICAL: One of your PIN retry counters is at 1. Be extremely careful with subsequent PIN entries."
    fi
}

# --- Parse Command-Line Arguments ---
# Check if being sourced for partial setup by 16-generate-gpg-on-yubikey.sh
if [[ "${1:-}" == "--partial-for-oncard-setup" ]]; then
    PARTIAL_SETUP_MODE=true
    YK_SERIAL="${2:-}"
    log_info "Running in partial setup mode for on-card key generation (Serial: ${YK_SERIAL})."
    # Skip full argument parsing and some initial steps if in partial mode
else
    PARTIAL_SETUP_MODE=false
    if [[ "$#" -eq 0 ]]; then
        usage # Show usage if no arguments are provided
    fi
    while [[ "$#" -gt 0 ]]; do
        case $1 in
            -h|--help) usage ;;
            --serial) YK_SERIAL="$2"; shift ;; # YubiKey serial number
            *) log_error "Unknown parameter passed: $1"; usage ;;
        esac
        shift
    done
done

if [ -z "$YK_SERIAL" ]; then
    log_error "YubiKey serial number must be provided via --serial."
    usage
fi

if ! $PARTIAL_SETUP_MODE; then
    log_info "Starting YubiKey GPG Provisioning for YubiKey Serial: ${YK_SERIAL}"
fi
log_debug "Target YubiKey Serial: ${YK_SERIAL}"

# --- Resolve Configuration Paths and Variables ---
GPG_MASTER_KEY_ID_FILE="${GPG_MASTER_KEY_ID_FILE:-.gpg_master_key_id}"
TEMP_GNUPGHOME_DIR_NAME="${TEMP_GNUPGHOME_DIR_NAME:-.gnupghome_temp_ykm}"
MASTER_KEY_ID_FILE_PATH="${BASE_DIR}/${GPG_MASTER_KEY_ID_FILE}"
TEMP_GNUPGHOME_PATH="${BASE_DIR}/${TEMP_GNUPGHOME_DIR_NAME}"
GPG_CARD_HOLDER_NAME="${GPG_USER_NAME:-}" # Optional cardholder name

log_debug "GPG_MASTER_KEY_ID_FILE: ${GPG_MASTER_KEY_ID_FILE}"
log_debug "TEMP_GNUPGHOME_DIR_NAME: ${TEMP_GNUPGHOME_DIR_NAME}"
log_debug "GPG_CARD_HOLDER_NAME: ${GPG_CARD_HOLDER_NAME}"
log_debug "GPG_TOUCH_POLICY_SIG: ${GPG_TOUCH_POLICY_SIG}"
log_debug "GPG_TOUCH_POLICY_ENC: ${GPG_TOUCH_POLICY_ENC}"
log_debug "GPG_TOUCH_POLICY_AUT: ${GPG_TOUCH_POLICY_AUT}"

# --- Prerequisite Checks ---
check_command "gpg"; check_command "ykman"; check_command "gpg-connect-agent"

# Validate configured touch policies
VALID_TOUCH_POLICIES=("on" "off" "fixed" "cached")
validate_touch_policy() {
    local policy_name="$1"; local policy_value="$2"
    if ! printf '%s\n' "${VALID_TOUCH_POLICIES[@]}" | grep -q -w "$policy_value"; then
        log_error "Invalid touch policy for ${policy_name}: '${policy_value}'. Must be one of: ${VALID_TOUCH_POLICIES[*]}."
        exit 1
    fi
}
validate_touch_policy "GPG Signature Key" "${GPG_TOUCH_POLICY_SIG}"
validate_touch_policy "GPG Encryption Key" "${GPG_TOUCH_POLICY_ENC}"
validate_touch_policy "GPG Authentication Key" "${GPG_TOUCH_POLICY_AUT}"

# --- Step 1: Verify GPG Master Key ID and GPG Home ---
if ! $PARTIAL_SETUP_MODE; then
    log_info "Step 1: Verifying Prerequisites and GPG Key ID."
    if [ ! -f "${MASTER_KEY_ID_FILE_PATH}" ]; then log_error "GPG Master Key ID file not found: ${MASTER_KEY_ID_FILE_PATH}. Run 01-generate-gpg-master-key.sh first."; exit 1; fi
    MASTER_KEY_ID=$(cat "${MASTER_KEY_ID_FILE_PATH}")
    if [ -z "${MASTER_KEY_ID}" ]; then log_error "Failed to read Master Key ID from ${MASTER_KEY_ID_FILE_PATH}."; exit 1; fi
    log_info "Using GPG Master Key ID: ${MASTER_KEY_ID}"
    log_debug "Read MASTER_KEY_ID: ${MASTER_KEY_ID} from ${MASTER_KEY_ID_FILE_PATH}"

    # Set GNUPGHOME to the temporary directory if it exists, otherwise use default.
    # This ensures GPG operations use the keys generated by script 01.
    if [ -d "${TEMP_GNUPGHOME_PATH}" ]; then
        log_info "Using temporary GPG home: ${TEMP_GNUPGHOME_PATH}"
        export GNUPGHOME="${TEMP_GNUPGHOME_PATH}"
        log_debug "Set GNUPGHOME to ${TEMP_GNUPGHOME_PATH}"
    else
        log_info "Temporary GPG home not found. Using default GPG home: ${HOME}/.gnupg"
        unset GNUPGHOME
        log_debug "Unset GNUPGHOME, using default."
    fi
fi

# --- Step 2: Connect to YubiKey ---
log_info "Step 2: Connecting to YubiKey (S/N: ${YK_SERIAL})."
# List YubiKeys to verify the target YubiKey is connected.
YKMAN_LIST_OUTPUT=$(ykman list --serials 2>&1); YKMAN_LIST_EC=$?
log_debug "ykman list output (EC:${YKMAN_LIST_EC}):\n${YKMAN_LIST_OUTPUT}"
if [ $YKMAN_LIST_EC -ne 0 ]; then log_error "Failed to list YubiKeys via ykman. EC:$YKMAN_LIST_EC. Output:\n${YKMAN_LIST_OUTPUT}"; exit 1; fi
if ! echo "${YKMAN_LIST_OUTPUT}" | grep -q -w "${YK_SERIAL}"; then log_error "YubiKey S/N ${YK_SERIAL} not found. Available:\n${YKMAN_LIST_OUTPUT}"; exit 1; fi

# Instruct gpg-agent to learn about the specific YubiKey.
# This helps ensure GPG targets the correct card if multiple are present.
log_info "Targeting YubiKey S/N ${YK_SERIAL} for GPG operations..."
GPG_CONNECT_OUTPUT=$(gpg-connect-agent "scd serialno ${YK_SERIAL}" "learn --force" /bye 2>&1); GPG_CONNECT_EC=$?
log_debug "gpg-connect-agent learn output (EC:${GPG_CONNECT_EC}):\n${GPG_CONNECT_OUTPUT}"
if [ $GPG_CONNECT_EC -ne 0 ]; then
    log_warn "Failed to set YK S/N ${YK_SERIAL} with gpg-connect-agent. EC:$GPG_CONNECT_EC. Output:\n${GPG_CONNECT_OUTPUT}"
    if ! confirm "Continue anyway (GPG might use the wrong card if multiple are connected)?"; then exit 1; fi
fi
sleep 1 # Give agent time to process

# Display initial YubiKey OpenPGP status
get_and_display_yk_openpgp_status "$YK_SERIAL"

# --- Step 3: Check YubiKey OpenPGP Applet Status & Optionally Reset ---
log_info "Step 3: Checking YubiKey OpenPGP Applet Status."
GPG_CARD_STATUS_OUTPUT=$(gpg --no-tty --card-status 2>&1); GPG_CARD_STATUS_EC=$?
log_debug "gpg --card-status output (EC:${GPG_CARD_STATUS_EC}):\n${GPG_CARD_STATUS_OUTPUT}"
if [ $GPG_CARD_STATUS_EC -eq 0 ]; then
    # Check if the signature key slot is already populated (a good indicator of existing keys).
    if echo "${GPG_CARD_STATUS_OUTPUT}" | grep -q "Signature key .....: [^N]"; then # [^N] means not "No data"
        log_warn "YubiKey OpenPGP applet (S/N ${YK_SERIAL}) appears to have keys already."
        if confirm "Do you want to RESET the OpenPGP applet on this YubiKey? This will WIPE ALL OpenPGP data on it."; then
            get_secure_input "Enter CURRENT Admin PIN for YK S/N ${YK_SERIAL} to authorize reset (if not default '${DEFAULT_ADMIN_PIN}', enter current): " NEW_ADMIN_PIN_FOR_RESET
            # Use ykman to reset the OpenPGP applet.
            YKMAN_RESET_OUTPUT=$(ykman -s "${YK_SERIAL}" openpgp reset --admin-pin "${NEW_ADMIN_PIN_FOR_RESET}" --force 2>&1); YKMAN_RESET_EC=$?
            log_debug "ykman openpgp reset output (EC:${YKMAN_RESET_EC}):\n${YKMAN_RESET_OUTPUT}"
            unset NEW_ADMIN_PIN_FOR_RESET
            if [ $YKMAN_RESET_EC -eq 0 ]; then
                log_success "YubiKey OpenPGP applet reset successfully."
                log_info "Reloading GPG agent to recognize the reset card..."
                # Instruct gpg-agent to re-scan and learn the card after reset.
                gpg-connect-agent "scd REOPEN" "scd KILLSCD" /bye >/dev/null 2>&1 || log_warn "gpg-connect-agent REOPEN/KILLSCD failed."
                sleep 2 # Give agent time
                gpg-connect-agent "scd serialno ${YK_SERIAL}" "learn --force" /bye >/dev/null 2>&1 || log_warn "gpg-connect-agent learn after reset failed."
                sleep 1
            else log_error "Failed to reset YK OpenPGP applet. EC:$YKMAN_RESET_EC. Output:\n${YKMAN_RESET_OUTPUT}"; exit 1; fi
        else log_info "Skipping OpenPGP applet reset."; fi
    else log_info "YubiKey OpenPGP applet appears empty or ready for provisioning."; fi
else log_error "Failed to get YK card status. EC:$GPG_CARD_STATUS_EC. Output:\n${GPG_CARD_STATUS_OUTPUT}"; exit 1; fi

# --- Step 4: Set YubiKey OpenPGP PINs ---
log_info "Step 4: Setting YubiKey OpenPGP PINs."
log_info "You will set a User PIN (for daily operations) and an Admin PIN (for administrative tasks like changing PINs or touch policies)."
log_warn "Choose strong, unique PINs. Default User PIN: '${DEFAULT_USER_PIN}', Default Admin PIN: '${DEFAULT_ADMIN_PIN}'."
# Get and confirm new User PIN
while true; do
    get_secure_input "Enter NEW User PIN (min ${OPENPGP_MIN_USER_PIN_LENGTH_CONFIG} chars, different from default '${DEFAULT_USER_PIN}'): " NEW_USER_PIN_VALUE
    if [ "${#NEW_USER_PIN_VALUE}" -lt "${OPENPGP_MIN_USER_PIN_LENGTH_CONFIG}" ]; then log_warn "User PIN too short (min ${OPENPGP_MIN_USER_PIN_LENGTH_CONFIG} chars).";
    elif [ "$NEW_USER_PIN_VALUE" == "$DEFAULT_USER_PIN" ]; then log_warn "User PIN should not be the default. Choose a unique PIN.";
    else break; fi
done
while true; do get_secure_input "Confirm NEW User PIN: " CONFIRM_NEW_USER_PIN_VALUE; if [ "$NEW_USER_PIN_VALUE" == "$CONFIRM_NEW_USER_PIN_VALUE" ]; then break; else log_warn "User PINs do not match."; fi; done
unset CONFIRM_NEW_USER_PIN_VALUE

# Get and confirm new Admin PIN
while true; do
    get_secure_input "Enter NEW Admin PIN (min ${OPENPGP_MIN_ADMIN_PIN_LENGTH_CONFIG} chars, different from default '${DEFAULT_ADMIN_PIN}'): " NEW_ADMIN_PIN_VALUE
    if [ "${#NEW_ADMIN_PIN_VALUE}" -lt "${OPENPGP_MIN_ADMIN_PIN_LENGTH_CONFIG}" ]; then log_warn "Admin PIN too short (min ${OPENPGP_MIN_ADMIN_PIN_LENGTH_CONFIG} chars).";
    elif [ "$NEW_ADMIN_PIN_VALUE" == "$DEFAULT_ADMIN_PIN" ]; then log_warn "Admin PIN should not be the default. Choose a unique PIN.";
    else break; fi
done
while true; do get_secure_input "Confirm NEW Admin PIN: " CONFIRM_NEW_ADMIN_PIN_VALUE; if [ "$NEW_ADMIN_PIN_VALUE" == "$CONFIRM_NEW_ADMIN_PIN_VALUE" ]; then break; else log_warn "Admin PINs do not match."; fi; done
unset CONFIRM_NEW_ADMIN_PIN_VALUE

log_info "Attempting to change PINs using GPG. If current PINs are not default, GPG will prompt for them."
# Prepare GPG commands for changing PINs and optionally setting cardholder name.
GPG_CARD_SETUP_COMMANDS_STRING=$(printf "admin\npasswd\n1\n%s\n%s\n%s\n3\n%s\n%s\n%s\nq\n" \
    "${DEFAULT_USER_PIN}" "${NEW_USER_PIN_VALUE}" "${NEW_USER_PIN_VALUE}" \
    "${DEFAULT_ADMIN_PIN}" "${NEW_ADMIN_PIN_VALUE}" "${NEW_ADMIN_PIN_VALUE}")

if [ -n "${GPG_CARD_HOLDER_NAME}" ]; then
    log_info "Setting card holder name to: ${GPG_CARD_HOLDER_NAME}"
    GPG_CARD_SETUP_COMMANDS_STRING+=$(printf "name\n%s\n\n" "${GPG_CARD_HOLDER_NAME}")
fi
GPG_CARD_SETUP_COMMANDS_STRING+="save\n"
log_debug "GPG card setup commands being sent (PINs are placeholders for gpg-agent interaction if not default):\n${GPG_CARD_SETUP_COMMANDS_STRING}"
# Execute GPG card edit commands.
GPG_CARD_EDIT_OUTPUT=$(printf "%s" "${GPG_CARD_SETUP_COMMANDS_STRING}" | gpg --no-tty --status-fd 1 --pinentry-mode loopback --command-fd 0 --card-edit 2>&1); GPG_CARD_EDIT_EC=$?
log_debug "gpg --card-edit output (EC:${GPG_CARD_EDIT_EC}):\n${GPG_CARD_EDIT_OUTPUT}"
if [ $GPG_CARD_EDIT_EC -eq 0 ]; then log_success "PINs and optional cardholder info setup attempted successfully via GPG.";
else log_error "GPG card edit failed. EC:$GPG_CARD_EDIT_EC. Output:\n${GPG_CARD_EDIT_OUTPUT}"; fi
log_warn "Ensure the NEW Admin PIN ('${NEW_ADMIN_PIN_VALUE}') was set correctly for subsequent steps."

# Display YubiKey OpenPGP status after PIN changes
get_and_display_yk_openpgp_status "$YK_SERIAL"

# Skip key transfer and touch policy steps if in partial setup mode for on-card generation
if ! $PARTIAL_SETUP_MODE; then
    # --- Step 5: Move GPG Subkeys to YubiKey ---
    log_info "Step 5: Moving GPG Subkeys to YubiKey."
    ensure_var_set "GPG_MASTER_PASSPHRASE" "Enter passphrase for GPG Master Key ('${MASTER_KEY_ID}') to authorize subkey transfer" --secure
    # Prepare GPG commands for moving subkeys to the card.
    # 'key N' selects subkey N. 'keytocard' moves it to slot N.
    # 'quit' followed by 'N' (No) is crucial to prevent GPG from deleting local private key stubs.
    KEYTOCARD_COMMANDS_STRING=$(printf "%s\nkey 1\nkeytocard\n1\nkey 1\nkey 2\nkeytocard\n2\nkey 2\nkey 3\nkeytocard\n3\nkey 3\nquit\nN\n" "${GPG_MASTER_PASSPHRASE}")

    log_info "Moving subkeys... You will be prompted for the NEW User PIN ('${NEW_USER_PIN_VALUE}')."
    log_warn "This script automates answering 'N' (No) to GPG's 'Save changes?' prompt. This is CRITICAL to keep local private key stubs, enabling backup/cloning of subkeys to another YubiKey."
    log_debug "GPG keytocard commands (passphrase redacted):\n$(printf "%s" "${KEYTOCARD_COMMANDS_STRING}" | sed '1s/.*/\[REDACTED PASSPHRASE]/')"
    # Execute GPG keytocard commands.
    GPG_KEYTOCARD_OUTPUT=$(printf "%s" "${KEYTOCARD_COMMANDS_STRING}" | gpg --no-tty --status-fd 1 --pinentry-mode loopback --command-fd 0 --expert --edit-key "${MASTER_KEY_ID}" 2>&1); GPG_KEYTOCARD_EC=$?
    log_debug "gpg keytocard output (EC:${GPG_KEYTOCARD_EC}):\n${GPG_KEYTOCARD_OUTPUT}"
    unset GPG_MASTER_PASSPHRASE # Unset passphrase from script memory
    if [ $GPG_KEYTOCARD_EC -ne 0 ]; then log_error "GPG keytocard failed. EC:$GPG_KEYTOCARD_EC. Output:\n${GPG_KEYTOCARD_OUTPUT}"; fi
    log_success "Subkey transfer to YubiKey attempted."

    # --- Step 6: Verify Subkeys on YubiKey ---
    log_info "Step 6: Verifying Subkeys on YubiKey."
    # List secret keys; subkeys on card should be marked with '>'.
    GPG_K_OUTPUT=$(gpg --no-tty -K "${MASTER_KEY_ID}" 2>&1)
    log_debug "gpg -K output after keytocard:\n${GPG_K_OUTPUT}"
    if echo "${GPG_K_OUTPUT}" | grep -E 'ssb>'; then log_success "Subkeys appear correctly provisioned on YubiKey (marked 'ssb>').";
    else log_warn "Could not verify all subkeys on YubiKey with 'ssb>'. Check 'gpg -K ${MASTER_KEY_ID}' manually."; fi

    # --- Step 7: Set Touch Policies ---
    log_info "Step 7: Setting Touch Policies for GPG Keys on YubiKey."
    log_info "Touch policies require physical touch for operations: SIG='${GPG_TOUCH_POLICY_SIG}', ENC='${GPG_TOUCH_POLICY_ENC}', AUT='${GPG_TOUCH_POLICY_AUT}'."
    log_warn "You will be prompted for the NEW Admin PIN ('${NEW_ADMIN_PIN_VALUE}') by ykman for each policy change."
    TOUCH_POLICY_ALL_SUCCESS=true

    # Set touch policy for Signature key
    YKMAN_TOUCH_SIG_OUTPUT=$(ykman -s "${YK_SERIAL}" openpgp keys set-touch sig "${GPG_TOUCH_POLICY_SIG}" --admin-pin "${NEW_ADMIN_PIN_VALUE}" --force 2>&1); YKMAN_TOUCH_SIG_EC=$?
    log_debug "ykman set-touch sig output (EC:${YKMAN_TOUCH_SIG_EC}):\n${YKMAN_TOUCH_SIG_OUTPUT}"
    if [ $YKMAN_TOUCH_SIG_EC -ne 0 ]; then log_error "Failed to set SIG touch. EC:$YKMAN_TOUCH_SIG_EC. Output:\n${YKMAN_TOUCH_SIG_OUTPUT}"; TOUCH_POLICY_ALL_SUCCESS=false; else log_info "SIG touch policy set."; fi

    # Set touch policy for Encryption key
    YKMAN_TOUCH_ENC_OUTPUT=$(ykman -s "${YK_SERIAL}" openpgp keys set-touch enc "${GPG_TOUCH_POLICY_ENC}" --admin-pin "${NEW_ADMIN_PIN_VALUE}" --force 2>&1); YKMAN_TOUCH_ENC_EC=$?
    log_debug "ykman set-touch enc output (EC:${YKMAN_TOUCH_ENC_EC}):\n${YKMAN_TOUCH_ENC_OUTPUT}"
    if [ $YKMAN_TOUCH_ENC_EC -ne 0 ]; then log_error "Failed to set ENC touch. EC:$YKMAN_TOUCH_ENC_EC. Output:\n${YKMAN_TOUCH_ENC_OUTPUT}"; TOUCH_POLICY_ALL_SUCCESS=false; else log_info "ENC touch policy set."; fi

    # Set touch policy for Authentication key
    YKMAN_TOUCH_AUT_OUTPUT=$(ykman -s "${YK_SERIAL}" openpgp keys set-touch aut "${GPG_TOUCH_POLICY_AUT}" --admin-pin "${NEW_ADMIN_PIN_VALUE}" --force 2>&1); YKMAN_TOUCH_AUT_EC=$?
    log_debug "ykman set-touch aut output (EC:${YKMAN_TOUCH_AUT_EC}):\n${YKMAN_TOUCH_AUT_OUTPUT}"
    if [ $YKMAN_TOUCH_AUT_EC -ne 0 ]; then log_error "Failed to set AUT touch. EC:$YKMAN_TOUCH_AUT_EC. Output:\n${YKMAN_TOUCH_AUT_OUTPUT}"; TOUCH_POLICY_ALL_SUCCESS=false; else log_info "AUT touch policy set."; fi

    unset NEW_ADMIN_PIN_VALUE; unset NEW_USER_PIN_VALUE # Unset PINs from script memory

    if $TOUCH_POLICY_ALL_SUCCESS; then log_success "Touch policies set successfully.";
    else log_error "One or more touch policy settings failed. Check ykman output and Admin PIN."; fi

    log_info "---------------------------------------------------------------------"
    log_success "YubiKey GPG Provisioning Complete for S/N ${YK_SERIAL} with Key ID ${MASTER_KEY_ID}."
    log_info "---------------------------------------------------------------------"
    log_info "Your YubiKey (S/N: ${YK_SERIAL}) should now be ready for GPG operations."
    log_warn "IMPORTANT: Remember your new User PIN and Admin PIN. They have been unset from script memory. Store them securely."
    log_warn "If you switch between YubiKeys that share the same GPG keys (e.g., a primary and a cloned backup),"
    log_warn "you MUST run the following command AFTER inserting the YubiKey you intend to use:"
    log_warn "  gpg-connect-agent \"scd serialno\" \"learn --force\" /bye"
    log_warn "This tells gpg-agent to associate GPG key stubs with the newly inserted card."
    log_info "Next recommended step: Run '03-backup-gpg-master-key.sh' if you haven't already backed up the master key."

    exit 0
fi

# If in partial setup mode, exit here after applet preparation.
if $PARTIAL_SETUP_MODE; then
    log_info "Partial setup for on-card key generation complete. YubiKey applet prepared."
    exit 0
fi
